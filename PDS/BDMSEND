BDMSEND  TITLE 'BDMSEND - SEND A MESSAGE TO A USERID IN SYS1.BRODCAST'
         SPACE 1
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  DOCUMENTATION:   THIS PROGRAM CAN BE RUN AS A TSO-IN-BATCH         *
*                   COMMAND.   NEED NOT BE AUTHORIZED.                *
*                                                                     *
*       Copyright (C) 1995-2025 Sam Golob Systems Programming LLC     *
*                 All Rights Reserved                                 *
*                                                                     *
*                                                                     *
*         SYNTAX:   BDMSEND USERID MESSAGE TEXT                       *
*                                                                     *
*       FUNCTION:   TO SEND A USERID MESSAGE TO A TSO USERID WHO IS   *
*                   DEFINED IN SYS1.BRODCAST.  WORKS ON SYS1.BRODCAST *
*                   INTERNALLY, WITHOUT USING THE SEND COMMAND.       *
*                                                                     *
*          AUTHOR:  SAM GOLOB               VERSION:   1.5.0A         *
*                                                                     *
*            DATE:  JULY 31, 2005                                     *
*                                                                     *
*       EXECUTION:  ALLOC F(BRODCAST) DA('SYS1.BRODCAST') SH REUSE    *
*                                                                     *
*         CHANGES:                                                    *
*                                                                     *
*       2007-06-07:  Rewrote program to speed it up.                  *
*                    ENQ on all records that are accessed except      *
*                     the second free record found (if it exists).    *
*                    Got rid of instream IKJZT30x macros.             *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*       I N S T R E A M    M A C R O S                                *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    STM   R15,R1,HEXSAVE
         LA    R1,&FROM
         LA    R0,&LEN
         LA    R15,&TO
         BAL   R9,HEX
         LM    R15,R1,HEXSAVE
         MEND
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE 1
*        REGS
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 1
SP000    EQU   0
         SPACE 1
BDMSEND  CSECT
         USING BDMSEND,R12,R11,R10
         B     BEGINN-*(,R15)
STRTCHAR DC    X'C0'           OPEN CURLY BRACKET
ENDCHAR  DC    X'D0'           CLOSE CURLY BRACKET
STRTCHA1 DC    X'7A'           COLON
ENDCHA1  DC    X'7A'           COLON
STRTCHA2 DC    X'7B'           POUND SIGN
ENDCHA2  DC    X'7B'           POUND SIGN
STRTCHA3 DC    X'7D'           SINGLE QUOTE
ENDCHA3  DC    X'7D'           SINGLE QUOTE
STRTCHA4 DC    X'7F'           DOUBLE QUOTE
ENDCHA4  DC    X'7F'           DOUBLE QUOTE
STRTCHA5 DC    X'7E'           EQUAL SIGN
ENDCHA5  DC    X'7E'           EQUAL SIGN
         DC    C'BDMSEND Ver 1.5.0A '
         DC    C'Copyright (c) 1995-2025 Sam Golob Systems Programming'
         DC    C' LLC - All Rights Reserved  '
         DC    CL16' &SYSDATE &SYSTIME '
         DC    CL6'HLASM '
         DC    C'&SYSVER'
         DC    C' '
BEGINN   DS    0H
         STM   R14,R12,12(R13)
         LR    R12,R15             LOAD FIRST BASE REGISTER
         LA    R11,4095(,R12)      LOAD SECOND BASE
         LA    R11,1(,R11)
         LA    R10,4095(,R11)      LOAD THIRD BASE
         LA    R10,1(,R10)
         LR    R4,R1               PRESERVE CPPL POINTER.
         GETMAIN RU,LV=DATALEN,SP=SP000,LOC=BELOW
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATAAREA,R13
         BAL   R9,INITCON          INITIALIZE CONSTANTS IN DATA AREA
         BAL   R9,GETPSCB          GET PSCB IF ANY (IN R2)
         SPACE 1
         LTR   R2,R2               ANY PSCB?
         BZ    EOJ8                GET OUT.  NOT TSO.
         BAL   R9,CPPLPTRS         STORE STUFF OUT OF THE CPPL
         BAL   R9,SETIOPL          SET UP IOPL FOR PUTLINE
*        BAL   R9,CHEKAUTH         ARE WE OPER OR ACCT ?
CONT0    LTR   R4,R4               ANY CPPL?
         BZ    EOJ8                NO.  GET OUT
         L     R1,0(,R4)           PT TO CMD BUFFER.
         LTR   R1,R1               ANY CMD BUFFER?
         BZ    EOJ4                GET OUT IF NONE
         LH    R3,0(,R1)           LOAD LENGTH.
         STH   R3,CMBLENG          SAVE COMMAND BUFFER LENGTH
         CH    R3,=H'4'            ANYTHING?
         BNH   EOJ4                NO.  GET OUT.
         LR    R5,R3               LENGTH OF COMMAND + 4
         ICM   R5,14,FULLZERO      CLEAR HI ORDER 3 BYTES
         LH    R3,2(,R1)           LOAD OFFSET.
         STH   R3,OFFSETT          SAVE OFFSET.
         SR    R5,R3               SUBTRACT OFFSET FROM FULL LENGTH+4
         SH    R5,=H'4'            CORRECT FOR LENGTH OF CMDBUFR HEADER
         BC    8,WMESS3            ZERO, SEND MESSAGE.............
         BC    5,EOJ8              LESS, OR OVERFLOW, OUT.
         BAL   R9,GETIDS           MAKE SURE YOU PULL THE NEWID OUT
*                                  OF THE KEYWORD (AND ITS LENGTH)
*                                  AND ALSO SAVE THE CURRENT ID&LENGTH
         BAL   R9,GETMSGT          OBTAIN AND SAVE MSG TEXT
ALLSET   CLC   NEWID(6),=C'ALL$#@'
         BNE   ONEID
*   IF YOU WANT ALL$#@ TO WORK, THEN CHANGE X'00' TO X'FF'
         MVI   ALLFLAG,X'00'
*        MVI   ALLFLAG,X'FF'       SEND MESSAGE TO ALL USERIDS.
ONEID    MVC   TRYID(8),NEWID      RUN USERID SCAN AGAINST NEW ID
DOBROD   OPEN  (BRODCAST,(UPDAT))
         TM    BRODCAST+48,X'10'
         BNO   WMESS1
         MVC   RNAM(3),ZEROS       ENQUEUE ON HEADER RECORD
         ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
         BAL   R9,HEADREAD         READ HEADER RECORD AND EXTRACT
*                                  RBA OF FIRST USER RECORD TO SEARCH
*                                  FOR THE USERID SLOT FOR OUR USERID.
*                                  THIS VALUE IS STORED IN SAVERBA(3).
         MVC   RNAM(3),TYP5RBA     ENQUEUE ON FREE SEARCH RECORD
         ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
         BAL   R9,GETFRSR
         BAL   R9,FINDFREE         FIND TWO FREE MESSAGE SLOTS
         MVC   RNAM(3),FREERBA     ENQUEUE ON FIRST FREE RECORD
         ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
*        MVC   RNAM(3),FRE2RBA     ENQUEUE ON SECOND FREE RECORD
*        ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
* - >
*        MVC   LINE,LINE-1
*        MVC   LINET(21),=C'I got past FINDFREE.'
*        LA    R0,53
*        BAL   R9,MSG
* - >
         BAL   R9,FINDUSER         FIND THE USERID RECORD
         MVC   RNAM(3),MYUSRBA     ENQUEUE ON USERID RECORD
         ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
         TM    CHAINFLG,X'01'
         BZ    NOTCHAIN
         BAL   R9,RECHAINO
NOTCHAIN DS    0H
         BAL   R9,WRITEMSG
         MVC   RNAM(3),MYUSRBA     ENQUEUE ON USERID RECORD
         DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
         MVC   RNAM(3),FREERBA     ENQUEUE ON FIRST FREE RECORD
         DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
*        MVC   RNAM(3),FRE2RBA     ENQUEUE ON FIRST FREE RECORD
*        DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
         BAL   R9,WRTFRSR
         MVC   RNAM(3),TYP5RBA     ENQUEUE ON FREE SEARCH RECORD
         DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
         MVC   RNAM(3),ZEROS       DEQ ON HEADER
         DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
         BAL   R9,WRITEND
         B     EOJ0
* ------------------------------------------------------------------ *
* ---    END OF MAIN ROUTINE TO SEND MESSAGE                     --- *
* ------------------------------------------------------------------ *
BADEND   MVC   LINE,LINE-1                COME HERE IF ID KEY NOT X'01'
         LA    R0,L'MESPREND+7             WRITE MESSAGE THAT
         MVC   LINET(L'MESPREND),MESPREND     THINGS ARE NOT
         BAL   R9,MSG                            SO GOOD.
*                                         GET HERE AT END OF USER RCDS
ENDUSER  DS    0H
         CLI   ALLFLAG,X'FF'                 ARE WE DOING ALL IDS ?
         BNE   NOTALL2                       NO. JUST FINISH THIS ONE.
         MVC   LINE,LINE-1                   YES. WE TOTAL 'EM ALL.
         LA    R0,60                           WRITE A BUNCH OF
         BAL   R9,MSG                          LINES AT THE END
         MVC   WK1ALL,MESALL                      WITH THE TOTAL COUNT
         MVC   WK1ALL+46(10),MASK10               AND ENDING MESSAGE
         ED    WK1ALL+46(10),TMSGCNT
         MVC   LINET(L'WK1ALL),WK1ALL
         LA    R0,L'WK1ALL+7
         BAL   R9,MSG                       THEN
         B     EOJ0                           GET THE HECK OUT
NOTALL2  MVC   LINE,LINE-1                  CLEAR LINE
         MVC   WK1NOUSR,MESNOUSR              AND JUST FINISH UP
         MVC   WK1NOUSR+32(7),TRYID             FOR THIS ID THAT
         MVC   LINET(L'WK1NOUSR),WK1NOUSR         YOU'VE BEEN
         LA    R0,L'WK1NOUSR+7                      DEALING WITH
         BAL   R9,MSG
ZEROUT   B     EOJ0                WE'RE DONE.
         SPACE 3
FULLMESS MVC   LINE,LINE-1                  WRITE MESSAGE THAT
         MVC   LINET,MESSFULL                 SYS1.BRODCAST
         LA    R0,L'MESSFULL+7                  IS
         BAL   R9,MSG                             FULL
         B     EOJ4                             AND GET OUT.
WMESS3   MVC   LINE,LINE-1                  WRITE MESSAGE THAT
         MVC   LINET,MESSAGE3                 SYS1.BRODCAST NOT ALLOC'D
         LA    R0,L'MESSAGE3+7                  TO DDNAME BRODCAST.
         BAL   R9,MSG
         B     EOJ4
WMESS2   MVC   LINE,LINE-1                  WRITE MESSAGE THAT
         MVC   LINET,MESSAGE2                 SYS1.BRODCAST NOT ALLOC'D
         LA    R0,L'MESSAGE2+7                  TO DDNAME BRODCAST.
         BAL   R9,MSG
         B     EOJ4
WMESS1   MVC   LINE,LINE-1                  WRITE MESSAGE THAT
         MVC   LINET,MESSAGE1                 SYS1.BRODCAST NOT ALLOC'D
         LA    R0,L'MESSAGE1+7                  TO DDNAME BRODCAST.
         BAL   R9,MSG
         B     EOJ4
EOJ      DS    0H                  BYE.
         CLOSE (BRODCAST)
         LR    R1,R13
         L     R13,4(,R13)
         FREEMAIN RU,LV=DATALEN,A=(R1),SP=SP000
         LR    R15,R5              DUMP IN UNCORRUPTED RETURN CODE.
         ST    R15,16(,R13)        PUT RC INTO PASSED SAVE AREA
         L     R14,12(,R13)        R14 ALONE
         LM    R0,R12,20(R13)      REST OF THE REGISTERS
         BR    R14                 BACK TO THE SYSTEM
EOJ0     SR    R5,R5               SET CC = 0.
         B     EOJ                 CONT.
EOJ4     LA    R5,4                SET CC = 4.
         B     EOJ                 CONT
EOJ8     LA    R5,8                SET CC = 8.
         B     EOJ                 CONT
EOJ12    LA    R5,12               SET CC = 12.
         B     EOJ                 CONT
EOJ16    LA    R5,16               SET CC = 16.
         B     EOJ                 CONT
         EJECT
*-----------------------------------------------------------------*
*---*                S U B R O U T I N E S                    *---*
*-----------------------------------------------------------------*
         SPACE 2
*-----------------------------------------------------------------*
*-- FEED THIS ROUTINE A USERID, AND IT WILL FIND OUT IF IT      --*
*-- EXISTS IN SYS1.BRODCAST.  IF IT DOES, THE RBA OF ITS RECORD --*
*-- IS RETURNED INTO MYUSRBA, THE USER SLOT IS RETURNED INTO    --*
*-- MYUSSLOT, AND THE MESSAGE POINTERS ARE RETURNED INTO THE    --*
*-- FIELD, SAVEPTRS.                                            --*
*-----------------------------------------------------------------*
FINDUSER DS    0H                  READ THROUGH USERID RECORDS
         ST    R9,SAVER9A
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,SAVERBA
*        MVC   LINET+10(18),=C'I got to FINDUSER.'
*        LA    R0,53
*        BAL   R9,MSG
* - >
FINDUSTR DS    0H
         CLC   SAVERBA(3),ZEROS    ARE WE AT THE END OF USERID RECORDS
         BE    ENDUSER             NO USERID LIKE THIS. DEAL WITH IT.
         LA    R6,9                COUNT OF USERS PER RECORD
         MVC   BLOCKNO,SAVERBA     GET RBA FOR READ
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(18),=C'Userid Record Read'
*        LA    R0,53
*        BAL   R9,MSG
* - >
         L     R3,MDLDECB+12       ADDRESS OF RECORD
         USING USDIR,R3
         MVC   LASTRBA(3),SAVERBA  SAVE CURRENT RBA
         MVC   SAVERBA(3),USDNEXT  GET NEXT RECORD'S RBA
         LA    R8,0                INITIALIZE USERID SLOT COUNTER
FUSRLOOP DS    0H
         MVC   USERID(8),BLANKS    ENSURE BLANK IN 8TH PLACE
         MVC   USERIDI(7),USDID    COPY WHO THIS IS
         CLC   USERIDI(7),ZEROS    IS THIS A REAL USER?
         BE    FTRYNEXT            NOPE. JUST GO TO NEXT ENTRY
         CLC   USERID(7),TRYID     IS THIS THE USERID WE WANT?
         BE    FSAVPTRS            YEP. GO DEAL WITH IT
FTRYNEXT LA    R3,13(,R3)          BUMP LOCATION TO NEXT USERID
         LA    R8,1(,R8)           BUMP COUNTER WITHIN RECORD
         ST    R6,SAVER6           SAVE COUNT FOR RETRY (IF "ALL")
         BCT   R6,FUSRLOOP         TRY FOR ANOTHER USER ENTRY
*                           FREE BUFFERS BEFORE GETTING ANOTHER RECORD.
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
         MVC   UMSGCNT(3),PACKZERO   ZERO THE USERID'S MESSAGE COUNTER
         B     FINDUSTR            END OF RECORD? GET ANOTHER.
         SPACE 3
FSAVPTRS DS    0H
         MVC   MYUSRBA(3),LASTRBA  SAVE RBA OF RECORD WITH MY USERID
         STC   R8,MYUSSLOT         SAVE SLOT IN RECORD
         MVC   SAVEPTRS(6),USDRBA  SAVE POINTERS TO MY MESSAGES
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,MYUSRBA
*        HEX   LINET+10,1,MYUSSLOT
*        HEX   LINET+15,3,SAVEPTRS
*        HEX   LINET+25,3,SAVEPTRS+3
*        MVC   LINET+35(19),=C'Found Userid Record'
*        LA    R0,61
*        BAL   R9,MSG
* - >
         CLC   USDRBA(3),=X'000000'
         BE    FINDUNMS
         OI    CHAINFLG,X'01'
         MVC   PREVEND(3),USDEND
         MVC   USDEND(3),FREERBA   RECHAIN USERID TO NEW MESSAGE
         MVC   STOREND(3),FREERBA  STORE NEW END VALUE FOR THIS USERID
         B     FINDUWRT            WRITE THE USERID RECORD BACK
FINDUNMS DS    0H
         MVC   USDRBA(3),FREERBA   RECHAIN USERID TO NEW MESSAGE
         MVC   STORRBA(3),FREERBA  STORE NEW BEG VALUE FOR THIS USERID
         MVC   USDEND(3),FREERBA   RECHAIN USERID TO NEW MESSAGE
         MVC   STOREND(3),FREERBA  STORE NEW END VALUE FOR THIS USERID
FINDUWRT DS    0H                  WRITE THE USERID RECORD BACK
         WRITE MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY, EXCLUSIVE CNTL    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
FINDUSRX DS    0H
*                           FREE BUFFERS BEFORE GETTING ANOTHER RECORD.
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
FINDUSRE DS    0H
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,MYUSRBA
*        HEX   LINET+10,1,MYUSSLOT
*        HEX   LINET+15,3,USDRBA
*        HEX   LINET+25,3,USDEND
*        MVC   LINET+35(19),=C'Rewritten Pointers '
*        LA    R0,61
*        BAL   R9,MSG
* - >
         DROP  R3
         L     R9,SAVER9A
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        GET THE NEW USERID FROM THE PARM, AND SAVE THE OLD ONE.  *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         USING PSCB,R2
GETIDS   DS    0H
         ST    R9,SAVER9O
         AR    R1,R3               POINT ...
         LA    R1,4(,R1)           ... TO CHAR.
         LA    R6,7                LOAD REG FOR BCT LOOP
         LR    R7,R1               INITIALIZE POINTER
         LA    R7,0(,R7)                TO FIRST CHARACTER OF ID
         LA    R8,0                INITIALIZE CHARACTER COUNT
CUTIDLEN CLI   0(R7),X'40'         IS THIS CHARACTER A BLANK?
         BE    NOMORCUT            YES, WE ARE AT THE END OF THE ID.
         LA    R7,1(,R7)           BUMP ANOTHER CHARACTER
         LA    R8,1(,R8)           COUNT ANOTHER CHARACTER
         CR    R8,R5               END OF COMMAND BUFFER ?
         BNL   NOMORCUT            YES. GET OUT NOW.
         BCT   R6,CUTIDLEN         TRY FOR BLANK AGAIN
NOMORCUT DS    0H
         MVC   NEWID(8),BLANKS     CLEAR FIELD
         BCTR  R8,0                SUBTRACT 1 FOR EXECUTE
         EX    R8,MOVEID           MAKE SUBCOMMAND INTO NEW ID
         LA    R8,1(,R8)           BUMP REG BACK TO WHERE IT WAS
         STC   R8,NEWPSCBL         SAVE NEW USER'S LENGTH
         OC    NEWID(8),BLANKS     UPPERCASE NEW USERID
         MVC   SAVEID(8),NEWID
         MVC   MESSENTU(7),NEWID
         MVC   OLDID(8),BLANKS     CLEAR FIELD
         MVC   OLDID(7),PSCBUSER   SAVE ORIGINAL USERID
         OC    OLDID(8),BLANKS     MAKE SURE ALL 8 CHARS ARE INITLIZED
         MVI   OLDPSCBL,X'00'      INITIALIZE FIELD
         MVC   OLDPSCBL(1),PSCBUSRL  SAVE ORIGINAL USERID LENGTH
         DROP  R2
         L     R9,SAVER9O
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*    FIND TWO FREE MESSAGE RECORDS
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
FINDFREE DS    0H
         ST    R9,SAVER9P          Save Work Registers.
         ST    R8,SAVER8
         ST    R7,SAVER7
         ST    R6,SAVER6
         MVC   BLOCKNO(3),FRSRRBA
         CLC   TYP5RBA,ZEROS
         BNE   SAVRGS01
         MVC   BLOCKNO(3),=X'000001'
         MVI   FULLFLAG,X'FF'
SAVRGS01 DS    0H
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(13),=C'BLOCKNO Start'
*        LA    R0,33
*        BAL   R9,MSG
* - >
         L     R8,HIWATER          USE HIWATER AS FINISH AMT
         L     R7,NUMRECS          LOAD TOTAL NUMBER OF RECS
         XR    R6,R6               ENSURE EMPTY TO BEGIN
         ICM   R6,7,BLOCKNO        LOAD STARTING POINT
         SR    R7,R6               SET UP BCT FOR LOOP
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(13),=C'BLOCKNO Init '
*        LA    R0,33
*        BAL   R9,MSG
* - >
STARTFSH DS    0H
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(13),=C'BLOCKNO Read '
*        LA    R0,33
*        BAL   R9,MSG
* - >
         L     R2,MDLDECB+20       ADDRESS OF KEY
         CLI   0(R2),X'FF'         BLANK USER MESSAGE RECORD?
         BE    FOUNDNEW            YES? FOUND ONE.
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
         XR    R6,R6
         ICM   R6,7,BLOCKNO        LOAD AMOUNT INTO REGISTER
         LA    R6,1(,R6)           ADD 1
         CR    R6,R8               HIGHER THAN STOPPING POINT?
         BH    FINDBEG             YES, START AT BEGINNING
         STCM  R6,7,BLOCKNO        POINT TO NEXT BLOCK NUMBER
         BCT   R7,STARTFSH         LOOP AND READ AGAIN
FOUNDNEW DS    0H
         TM    FREEFLAG,X'01'      GOT THE FIRST ONE ALREADY?
         BO    FOUND2ND
         OI    FREEFLAG,X'01'      TELL EM WE HAVE THE FIRST FREE
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(15),=C'BLOCKNO Found 1'
*        LA    R0,33
*        BAL   R9,MSG
* - >
         MVC   FREERBA(3),BLOCKNO  SAVE RBA OF FREE RECORD
*  Increase by 1 for NFRERBA if you need to, here.
FIND2ND  DS    0H
         ICM   R6,7,BLOCKNO        LOAD AMOUNT INTO REGISTER
         LA    R6,1(,R6)           ADD 1
         CR    R6,R8               HIGHER THAN STOPPING POINT?
         BH    FINDBEG             YES, START AT BEGINNING
         STCM  R6,7,BLOCKNO        POINT TO NEXT BLOCK NUMBER
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(14),=C'BLOCKNO Find 2'
*        LA    R0,33
*        BAL   R9,MSG
* - >
         BCT   R7,STARTFSH         LOOP AND READ AGAIN
         B     FINDFEND            AND DO IT AGAIN, SAM
FOUND2ND DS    0H
         TM    FREEFLAG,X'03'
         BO    FINDFEND
         OI    FREEFLAG,X'02'      TELL EM WE HAVE BOTH OF THEM
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(15),=C'BLOCKNO Found 2'
*        LA    R0,33
*        BAL   R9,MSG
* - >
         MVC   FRE2RBA(3),BLOCKNO  SAVE RBA OF FREE RECORD
         B     FINDFENF
* ----- >
FINDBEG  DS    0H
         TM    FREEFLAG,X'03'
         BO    FINDFEND
         CLI   FULLFLAG,X'FF'      CHECK IF WE WENT FROM BEGIN
         BNE   FINDGOON            YES. WE KNOW BCAST IS FULL
         L     R6,SAVER6           RESTORE REGISTER
         L     R7,SAVER7           RESTORE REGISTER
         L     R8,SAVER8           RESTORE REGISTER
         TM    FREEFLAG,X'01'      DID WE FIND AT LEAST THE FIRST FREE?
         BZ    FINDFULL
         MVC   FRE2RBA(3),FREERBA
         B     FINDFEND
FINDFULL DS    0H
         B     FULLMESS            BROADCAST FULL, AND OUT
FINDGOON DS    0H
         MVI   FULLFLAG,X'FF'      WE'RE NOW SEARCHING BEGINNG
         ICM   R8,7,FRSRRBA        FINISH AT FREE SEARCH REC
         LA    R7,1(,R8)           SET UP BCT REGISTER
         LA    R6,1                START SEARCH AT RECORD 2
         STCM  R6,7,BLOCKNO        LET READ KNOW ABOUT IT
         SR    R7,R6               SET UP BCT FOR LOOP
         B     STARTFSH            DO LOOP OVER AGAIN-1ST PART
FINDFENF DS    0H
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
FINDFEND DS    0H
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,FREERBA
*        MVC   LINET+10(7),=C'FREERBA'
*        LA    R0,30
*        BAL   R9,MSG
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,FRE2RBA
*        MVC   LINET+10(7),=C'FRE2RBA'
*        LA    R0,30
*        BAL   R9,MSG
* - >
         L     R6,SAVER6           RESTORE REGISTER
         L     R7,SAVER7           RESTORE REGISTER
         L     R8,SAVER8           RESTORE REGISTER
         L     R9,SAVER9P
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*    WRITE A MESSAGE, GIVEN THE RBA
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
WRITEMSG DS    0H
         ST    R9,SAVER9Q
         MVC   BLOCKNO(3),FREERBA
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         L     R2,MDLDECB+20       ADDRESS OF KEY
         CLI   0(R2),X'FF'         BLANK USER MESSAGE RECORD?
         BE    WRITEGO1            YES. GO ON PROCESSING IT
* ---------------------------------------------------------
*  TRYING TO WRITE ON THE WRONG TYPE OF RECORD.  BRODCAST
*  PROBABLY IS FULL.  CHECK TO SEE IF WE LOOKED ENOUGH
*  FOR A FREE RECORD.  TWO PASSES THROUGH BRODCAST.
* ---------------------------------------------------------
         CLI   FULLFLAG,X'FF'      WE TRIED FINDFREE TWICE?
         BE    FULLMESS            YES. BRODCAST IS FULL-OUT
WRITEGO1 MVI   0(R2),X'03'         SHOW IT'S A USED MESSAGE
         L     R3,MDLDECB+12       ADDRESS OF RECORD
         USING USMSG,R3
         ST    R7,SAVER7           SAVE WORK REGISTER
         MVC   USMLNG(1),LENTHMSG+3  PLUG IN LENGTH OF MESSAGE
         MVC   USMTEXT(125),BLANKMSG   FILL TEXT WITH BLANKS
         MVC   USMNEXT(3),ZEROS    SHOW MSG IS LAST IN CHAIN
         XR    R7,R7
         IC    R7,LENTHMSG+3       SET UP EXECUTE
         BCTR  R7,0                LOWER FOR MOVE
         EX    R7,MOVEMESG         MOVE MESSAGE INTO RECORD
         DROP  R3
         WRITE MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY, EXCLUSIVE CNTL    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
WRITEMND FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
WRITENDX L     R7,SAVER7
         L     R9,SAVER9Q
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        GET THE MESSAGE TEXT FOR THE MESSAGE TO BE SENT.         *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETMSGT  DS    0H                  GET MESSAGE TEXT TO SEND
         ST    R9,SAVER9C
         ST    R7,SAVEWRK7         SAVE REGISTER CONTENTS
         ST    R8,SAVEWRK8         SAVE REGISTER CONTENTS
         L     R3,0(,R4)           LOAD ADDRESS OF CMD BUFFER
         LH    R8,CMBLENG          TOTAL LENGTH OF CMD BUFFER
         LA    R3,4(,R3)           COMPENSATE FOR HEADER
         SH    R8,=H'4'            AND MINUS HEADER LENGTH
         LH    R7,OFFSETT          LOAD OFFSET VALUE
         LA    R3,0(R7,R3)         POINT TO BEGINNING OF CMD
         SR    R8,R7               CMD BUFFER LNG MINUS OFFSET
         XR    R7,R7               ZERO REGISTER
         IC    R7,NEWPSCBL         LOAD LENGTH OF USERID
         LA    R3,0(R7,R3)         POINT PAST USERID
         SR    R8,R7               SUBTRACT USERID LENGTH
         BC    8,WMESS2            ZERO, ISSUE MESSAGE.
         BC    5,EOJ8              LESS, OVERFLOW, GET OUT
         LR    R7,R8               INITIALIZE MESSAGE LENGTH
FRSTBLNK DS    0H                  IF NON-BLANK,ASSUME MESSAGE
*                                  STARTS HERE.
         CLI   0(R3),X'40'         ARE WE AT A BLANK?
         BE    LEADBLNK            YES, LOOK FOR MORE BLANKS
         B     BLANKEND            NO, ASSUME MSG STARTS HERE
LEADBLNK DS    0H                  BUMP PAST LEADING BLANKS
         CLI   0(R3),X'40'         IS THIS CHAR A BLANK?
         BNE   CLOSEBRK            NO, END LOOP
         LA    R3,1(,R3)           BUMP TO NEXT CHARACTER
         BCTR  R7,0                MESSAGE IS 1 CHAR SHORTER
         BCT   R8,LEADBLNK         LOOP TILL 1ST NON-BLANK
CLOSEBRK DS    0H
         CLC   STRTCHAR(1),0(R3)   Is the Start Character here?
         BE    CHAR00              Not the first non-blank
         CLC   STRTCHA1(1),0(R3)   Is the Start Character here?
         BE    CHAR01              Not the first non-blank
         CLC   STRTCHA2(1),0(R3)   Is the Start Character here?
         BE    CHAR02              Not the first non-blank
         CLC   STRTCHA3(1),0(R3)   Is the Start Character here?
         BE    CHAR03              Not the first non-blank
         CLC   STRTCHA4(1),0(R3)   Is the Start Character here?
         BE    CHAR04              Not the first non-blank
         CLC   STRTCHA5(1),0(R3)   Is the Start Character here?
         BE    CHAR05              Not the first non-blank
         B     BLANKEND
CHAR00   DS    0H
         MVC   STCH(1),STRTCHAR
         MVC   ENCH(1),ENDCHAR
         BAL   R9,CHSTREND
         B     BLANKEND
CHAR01   DS    0H
         MVC   STCH(1),STRTCHA1
         MVC   ENCH(1),ENDCHA1
         BAL   R9,CHSTREND
         B     BLANKEND
CHAR02   DS    0H
         MVC   STCH(1),STRTCHA2
         MVC   ENCH(1),ENDCHA2
         BAL   R9,CHSTREND
         B     BLANKEND
CHAR03   DS    0H
         MVC   STCH(1),STRTCHA3
         MVC   ENCH(1),ENDCHA3
         BAL   R9,CHSTREND
         B     BLANKEND
CHAR04   DS    0H
         MVC   STCH(1),STRTCHA4
         MVC   ENCH(1),ENDCHA4
         BAL   R9,CHSTREND
         B     BLANKEND
CHAR05   DS    0H
         MVC   STCH(1),STRTCHA5
         MVC   ENCH(1),ENDCHA5
         BAL   R9,CHSTREND
         B     BLANKEND
BLANKEND DS    0H                  SAVE MESSAGE TEXT NOW.
         BCTR  R7,0                ONE LESS FOR EXECUTE
         MVC   MSGTEXT(125),BLANKMSG   BLANK SEND MSG AREA
         EX    R7,MOVEMSGG         MOVE THE MESSAGE INTO IT
         MVC   LINE,LINE-1         CLEAR MESSAGE LINE
         MVC   LINE,MSGTEXT        MOVE TEXT IN
         LA    R0,1(,R7)           LOAD TRUE MESSAGE LENGTH
         BAL   R9,MSG              GO WRITE MESSAGE TEXT
         LA    R7,1(,R7)           LOAD TRUE MESSAGE LENGTH
         ST    R7,LENTHMSG
         L     R7,SAVEWRK7         RESTORE REGISTER CONTENTS
         L     R8,SAVEWRK8         RESTORE REGISTER CONTENTS
         L     R9,SAVER9C
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        READ THE SYS1.BRODCAST HEADER RECORD AND COPY FIELDS.    *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEADREAD DS    0H
         ST    R9,SAVER9L
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOKZERO,MF=E       RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         L     R3,MDLDECB+12       ADDRESS OF RECORD
         USING R1BC,R3             ADDRESSABILITY TO HEADER RECORD MAP
         MVC   SAVERBA(3),R1USPTR  SAVE RBA OF FIRST USER DIR RECORD
         MVC   NUMRECS(4),R1RECNUM   SAVE TOTAL NUMBER OF RECORDS
         ST    R7,SAVER7           SAVE REGISTER
         L     R7,NUMRECS          PUT NUMBER OF RECORDS IN
         BCTR  R7,0                MINUS ONE
         ST    R7,HIWATER          HIGHEST RBA PERMITTED
         L     R7,SAVER7           RESTORE REGISTER
         MVC   LEVEL(7),R1LEVEL    LEVEL+6 IS VERSION OF TSO
         CLC   LEVEL+6(1),=C'2'    IS THIS TSO LEVEL 1?
         BL    SKIPFREE            YEP. NO TYPE 5 RECORD ADDRESS
         MVC   TYP5RBA(3),R1FRESRH    STORE RBA OF TYPE 5
SKIPFREE DS    0H
         DROP  R3
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
         L     R9,SAVER9L
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
MSG      DS    0H
         ST    R9,SAVER9M
         LA    R1,LINE             WRITE A LINE USING PUTLINE FACILITY
*        LOAD LENGTH OF MESSAGE INTO R0 BEFORE CALLING THIS ROUTINE.
         BAL   R14,PUTLINE
         MVC   LINE,LINE-1
         L     R9,SAVER9M
         BR    R9
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        ROUTINE TO DISPLAY HEX VALUES                            *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         ST    R9,SAVER9N
         MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         L     R9,SAVER9N
         BR    R9                  RETURN TO CALLER
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        DATA AREAS THAT NEED TO BE INITIALIZED AT THE BEGINNING  *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
INITCON  DS    0H
         ST    R9,SAVER9D
         MVI   LINE-1,C' '         INITIALIZE BLANK
         MVC   TMSGCNT(5),PACKZER5 INITIALIZE COUNTER
         MVC   WK1TOTAL,MESTOTAL    INIT AREAS
         MVC   WK1NOUSR,MESNOUSR
         MVC   WK1ALL,MESALL
         MVC   MESSENTU(8),BLANKS
         MVC   LEVEL(7),BLANKS
         MVC   TYP5RBA(3),ZEROS        ZERO OUT
         MVC   FSRCRBA(3),ZEROS          ALL THE RBA
         MVC   NEXTRBA(3),ZEROS            STORAGE AREAS
         MVC   NFRERBA(3),ZEROS
         MVC   MINRBA(3),=X'FFFFFF'    PUT A LARGE VALUE IN
         MVI   ALLFLAG,X'00'
         MVI   FULLFLAG,X'00'
         MVI   FREEFLAG,X'00'
         MVI   CHAINFLG,X'00'
         MVC   MSGTEXT(125),BLANKMSG   MOVE BLANKS TO MSG AREA
         MVC   OFFSETT(2),ZEROS
         MVC   CMBLENG(2),ZEROS
         MVC   NUMRECS(4),ZEROS
         XC    HIWATER(4),HIWATER      PREVENT S0CX
         MVC   NFRERBA(3),ZEROS
         L     R9,SAVER9D
         BR    R9
* ------------------------------------------------------------------ *
GETPSCB  DS    0H
         ST    R9,SAVER9E
         L     R1,16               POINT TO CVT.
         L     R1,0(,R1)           POINT TO TCB/ASCB WORDS
         L     R1,4(,R1)           POINT TO TCB.
         L     R1,X'B4'(,R1)       POINT TO JSCB.
         L     R1,X'108'(,R1)      POINT TO PSCB.
         LA    R2,0(,R1)           CLEAR HIGH BYTE.  DUMP INTO R2
         L     R9,SAVER9E
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*              SAVE CPPL POINTERS                                 *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         USING CPPL,R4
CPPLPTRS DS    0H
         ST    R9,SAVER9F
         L     R6,CPPLUPT          SAVE CPPL POINTERS, SUCH AS:
         ST    R6,SAVEUPT             THE UPT
         L     R6,CPPLPSCB
         ST    R6,SAVEPSCB            THE PSCB
         L     R6,CPPLECT
         ST    R6,SAVEECT             THE ECT
         L     R6,CPPLCBUF
         ST    R6,CMBUFAD             THE COMMAND BUFFER ADDRESS
         ST    R4,SAVECPPL            AND THE CPPL ADDRESS ITSELF
         LA    R6,0
         L     R9,SAVER9F
         BR    R9
         DROP  R4
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*              TEST IF USER HAS PSCB AUTHORIZATION.               *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         USING PSCB,R2
CHEKAUTH DS    0H
         ST    R9,SAVER9G
         TM    PSCBATR1,PSCBACCT   ACCT USER?
         BO    CONT0               YES.  CONTINUE.
         TM    PSCBATR1,PSCBCTRL   OPER USER?
         BZ    EOJ4                NO.  GET OUT.
         DROP  R2
         L     R9,SAVER9G
         BR    R9
* ------------------------------------------------------------------- *
CHSTREND DS    0H
         ST    R9,SAVER9B
         ST    R3,SAVER3A
         ST    R7,SAVER7A
         BCTR  R7,0                Yes it is. So Msg is one char less.
         LA    R3,1(,R3)           Bump to real start character
         ST    R5,SAVER5           Save work register
         XR    R5,R5               Zero it to make sure
         LA    R5,0(R7,R3)
         BCTR  R5,0                Point to end character
         CLC   ENCH(1),0(R5)       Is it equal to special character?
         BNE   EGTMSG              No. Don't drop last char.
         BCTR  R7,0                Lower msg length by one.
EGTMSG   DS    0H
         L     R5,SAVER5           Restore work register.
CHSTRENE DS    0H
         L     R9,SAVER9B
         BR    R9
STCH     DS    X
ENCH     DS    X
* ------------------------------------------------------------------- *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        FINISH WRITING END MESSAGES FOR USERID.                  *
*        IF ALLFLAG IS ON, GO TO THE NEXT ID, AND IF NOT,         *
*        JUST GET OUT.                                            *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
WRITEND  DS    0H
         ST    R9,SAVER9K
         MVC   LINE,LINE-1                     WRITE
         MVC   LINE,MESSENT                     END OF USER LINE
         MVC   MESSENT+25(7),SAVEID
         LA    R0,L'MESSENT+8
         BAL   R9,MSG
NOTALL4  MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         L     R9,SAVER9K
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
************************************************************
*        SET UP IOPL FOR PUTLINE                           *
************************************************************
         SPACE
         USING CPPL,R4
SETIOPL  DS    0H
         ST    R9,SAVER9L
         LA    R15,MYIOPL
         USING IOPL,R15
         MVC   IOPLUPT(4),CPPLUPT
         MVC   IOPLECT(4),CPPLECT
         DROP  R4
         LA    R0,MYECB
         ST    R0,IOPLECB
         XC    MYECB,MYECB
         LA    R0,MYPTPB
         ST    R0,IOPLIOPB
         DROP  R15
         SPACE
         L     R15,CVTPTR          POINT TO CVT                  JDM1
         USING CVTMAP,R15          GET ADDRESSABILITY            JDM1
         TM    CVTPUTL,X'80'       IS PUTLINE LOADED? (VS2)      JDM1
         BNO   PUTLOAD             NO - BRANCH TO LOAD
         L     R15,CVTPUTL         YES - USE CVTPUTL             JDM1
         DROP  R15                                               JDM1
         B     PUTLOADX            BRANCH AROUND LOAD
PUTLOAD  LA    R0,=CL8'IKJPUTL '
         LOAD  EPLOC=(0)
         LR    R15,R0              GET ENTRY ADDRESS
         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE
PUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS
         L     R9,SAVER9L
         BR    R9
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETFRSR  DS    0H
         ST    R9,SAVER9S
         CLC   TYP5RBA(3),ZEROS    IS THERE A TYPE 5 RECORD IN BRODCAS
         BE    GETFRSRA
         MVC   BLOCKNO,TYP5RBA     GET RBA FOR READ
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         L     R3,MDLDECB+12       ADDRESS OF RECORD
         USING FREESRCH,R3
         MVC   FRSRRBA(3),FSEARCH
         DROP  R3
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
         B     GETFRSRE
GETFRSRA DS    0H
         MVC   FRSRRBA(3),=X'000001'
GETFRSRE DS    0H
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,FRSRRBA
*        LA    R0,30
*        BAL   R9,MSG
* - >
         L     R9,SAVER9S
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
RECHAINO DS    0H
         ST    R9,SAVER9T
         MVC   RNAM(3),PREVEND     ENQUEUE ON PREVIOUS MESSAGE
         ENQ   (QNAM,RNAM,E,,SYSTEM),MF=(E,ENQUSER)
         MVC   BLOCKNO(3),PREVEND
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,BLOCKNO
*        MVC   LINET+10(18),=C'Last Msg Rechained'
*        LA    R0,53
*        BAL   R9,MSG
* - >
         L     R2,MDLDECB+20       Address of Key
         CLI   0(R2),X'03'
         BNE   BADEND
         L     R3,MDLDECB+12       Address of Record
         USING USMSG,R3
         MVC   USMNEXT(3),FREERBA
         WRITE MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY, EXCLUSIVE CNTL    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         DROP  R3
*                           FREE BUFFERS BEFORE GETTING ANOTHER RECORD.
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
RECHAINS DS    0H
         MVC   RNAM(3),PREVEND     DEQUEUE ON PREVIOUS MESSAGE
         DEQ   (QNAM,RNAM,,SYSTEM),RET=HAVE,MF=(E,ENQUSER)
         L     R9,SAVER9T
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
WRTFRSR  DS    0H
         ST    R9,SAVER9U
         CLC   TYP5RBA(3),ZEROS    IS THERE A TYPE 5 RECORD IN BRODCAS
         BE    WRTFRSRE
         MVC   BLOCKNO,TYP5RBA     GET RBA FOR READ
         READ  MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY                    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         L     R3,MDLDECB+12       ADDRESS OF RECORD
         USING FREESRCH,R3
         MVC   FSEARCH(3),FRE2RBA  REPLACE FREE SEARCH RBA
         WRITE MDLDECB,            ECB ADDRESS TO POST                 X
               DI,                 USE DATA AND KEY, EXCLUSIVE CNTL    X
               BRODCAST,           DCB TO USE FOR READ                 X
               'S',                DO DYNAMIC BUFFERING                X
               'S',                GET LENGTH FROM DCB                 X
               'S',                KEY + DATA ARE READ SEQUENTIALLY    X
               BLOCKNO,MF=E        RBA OF THE RECORD
         SPACE
         CHECK MDLDECB
         FREEDBUF MDLDECB,         DECB ADDR USED TO READ              X
               D,                  USED BDAM READ                      X
               BRODCAST            DCB FOR PROCESS DATA SET
WRTFRSRE DS    0H
* - >
*        MVC   LINE,LINE-1
*        HEX   LINET,3,FRE2RBA
*        MVC   LINET+10(19),=C'New Free Search RBA'
*        LA    R0,36
*        BAL   R9,MSG
* - >
         DROP  R3
         L     R9,SAVER9U
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
************************************************************
*        PUTMSG ROUTINE                                    *
************************************************************
         SPACE
PUTMSG   STM   R14,R1,PUTSAVE
         XC    MYOLD(8),MYOLD
         XC    MYSEG1(4),MYSEG1
         MVC   MYPTPB(12),MODLPTPM
         LA    R14,1               NO. OF MESSAGE SEGMENTS
         ST    R14,MYOLD
         LA    R14,MYSEG1          POINT TO 1ST SEGMENT
         ST    R14,MYOLD+4
         LR    R14,R0              LENGTH IN R0
         LA    R14,4(,R14)         ADD 4
         LA    R15,MYSEG1+4
         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?
         BE    *+16                YES - BRANCH
         LA    R14,1(,R14)         ADD 1 TO LENGTH
         MVI   0(R15),C' '         INSERT LEADING BLANK
         LA    R15,1(,R15)         BUMP POINTER
         STH   R14,MYSEG1
         LR    R14,R0
         BCTR  R14,0
         B     *+10
         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN
         EX    R14,*-6
         LA    R1,MYIOPL
         L     R15,MYPUTLEP
         SPACE
         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,(1))
         SPACE
         LM    R14,R1,PUTSAVE
         BR    R14
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
************************************************************
*        PUTLINE ROUTINE                                   *
************************************************************
         SPACE
PUTLINE  STM   R14,R1,PUTSAVE
         XC    MYSEG1(4),MYSEG1
         MVC   MYPTPB(12),MODLPTPB
         LR    R14,R0              LENGTH IN R0
         LA    R14,4(,R14)         ADD 4
         STH   R14,MYSEG1
         LR    R14,R0
         BCTR  R14,0
         B     *+10
         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN
         EX    R14,*-6
         LA    R1,MYIOPL
         L     R15,MYPUTLEP
         SPACE
         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))
         SPACE
         LM    R14,R1,PUTSAVE
         BR    R14
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         EJECT
*-----------------------------------------------------------------*
*----         FIXED DATA AREAS THAT DON'T CHANGE.             ----*
*-----------------------------------------------------------------*
PACKZERO DC    PL3'0'
PACKZER5 DC    PL5'0'
FULLZERO DC    F'0'
* - - - - - - - - - - - - - - - - - - - - - - - - *
MOVEID   MVC   NEWID(*-*),0(R1)    EXECUTED
         USING USMSG,R3
MOVEMESG MVC   USMTEXT(*-*),MSGTEXT  EXECUTED
         DROP  R3
         USING USMSG,R2
MOVEMSG  MVC   LINET(*-*),USMTEXT  EXECUTED
         DROP  R2
MOVEMSGG MVC   MSGTEXT(*-*),0(R3)  EXECUTED
* - - - - - - - - - - - - - - - - - - - - - - - - *
BLANKS   DC    C'        '         8 BLANKS
BLANKMSG DC    CL125' '
BLOKZERO DC    X'000000'           BLOCK NUMBER OF BROADCAST HEADER
ZEROS    DS    0CL8
ZERREC   DS    0CL128
ZERENTRY DC    X'000000000000'     SHOW USERID HAS NO MESSAGES WAITING
         DC    X'0000'
         DC    121X'00'
MESSAGE1 DC    C'BAD OPEN - ALLOC F(BRODCAST) DA(SYS1.BRODCAST) SH REU'
MESSAGE2 DC    C'YOU HAVE TO SPECIFY MESSAGE TEXT AFTER THE USERID'
MESSAGE3 DC    C'YOU HAVE TO SPECIFY A USERID AFTER THE COMMAND NAME'
MESSEND  DC    C'* - - - - END OF MESSAGES FOR THIS USER - - - - *'
MESSENT  DC    C'MESSAGE SENT TO USERID: '
MESSENTU DC    CL8'        '
MESTOTAL DC    C'USER         HAD           DEFERRED TSO MESSAGES'
MESSFULL DC    C'SYS1.BRODCAST IS FULL.  NO ROOM TO WRITE MESSAGES.'
MESALL DC C'TOTAL DEFERRED TSO MESSAGES IN SYS1.BRODCAST              '
MESNOUSR DC    C'* - - NO USERID RECORD FOR USER          - - *'
MESPREND DC    C'?????  PRELIMINARY END OF USERID RECORDS - - *'
MASK6    DC    XL6'402020202120'
MASK10   DC    XL10'40202020202020202120'
BPARM    DC    AL2(BPARME-BPARM,0),C'NON'
BPARME   EQU   *
         DS    0F
QNAM     DC    CL8'SYSIKJBC'
RNAME    DC    X'000000'
         SPACE 3
BRODCAST DCB   DDNAME=BRODCAST,    JCL CONNECTION                      X
               BLKSIZE=129,        LENGTH OF FILES BLOCK               X
               DSORG=DA,           IS DIRECT ACCESS FILE               X
               MACRF=(RISXC,WIC),  3 BYTE RBA, DYNAMIC BUF, READ/CHECK X
               OPTCD=R,            3 BYTE RBA WILL BE USED             X
               RECFM=F,            FIXED LENGTH                        X
               BUFNO=2,            # OF BUFS TO GET DYNAMICALLY        X
               KEYLEN=1,           SIZE OF KEY                         X
               BUFL=130            KEYLEN + BLKSIZE
         SPACE 3
         LTORG
         SPACE
MODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L
         SPACE
MODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L
         DS    0F
ENQUSER  ENQ   (QNAM,RNAME,E,,SYSTEM),MF=L
         SPACE 3
*-----------------------------------------------------------------*
*----         GETMAINED DATA AREA FIELDS                      ----*
*-----------------------------------------------------------------*
DATAAREA DSECT
SAVE     DS    9D
CMBUFAD  DS    F                   COMMAND BUFFER ADDRESS
NEWID    DC    C'        '         STORE PARM USERID HERE
         DS    CL72                PADDING
ADDADR   DS    0CL12
UMSGCNT  DC    PL3'0'              COUNT OF MESSAGES FOR EACH USER
TMSGCNT  DC    PL5'0'              COUNT OF ALL MESSAGES DISPLAYED
NEXT     DS    F                   FOR IKJIFRIF ADD ADDRESS
OLDID    DC    C'        '         STORE OLD USERID HERE
LEVEL    DS    0CL7                LEVEL OF SYS1.BRODCAST
LEVELLIT DS    CL6                    LITERAL 'LEVEL'
LEVELLEV DS    CL1                       LEVEL NUMBER - CHAR FMT
SAVEPTRS DC    X'000000000000'     SAVE MSG POINTERS FOR NEW USERID
SVMYPTRS DC    X'000000000000'     SAVE MSG POINTERS FOR MY USERID
FINDPTRS DC    X'000000000000'     SAVE MSG POINTERS FOR MY USERID
WRITPTRS DC    X'000000000000'     NEW MSG POINTER TO WRITE
CMPRPTRS DC    X'000000000000'     COMPARE POINTERS FOR FINDUSR RTN
OLDPSCBL DC    X'00'               STORE OLD PSCBUSRL HERE
NEWPSCBL DC    X'00'               STORE NEW PSCBUSRL HERE
TYP5RBA  DC    X'000000'           STORE ADDRESS OF TYPE X'05'
FRSRRBA  DC    X'000000'           STORE ADDRESS OF TYPE X'05'
BLOCKNO  DC    X'000000'           STORE BLOCK NUMBER FOR READ
LASTRBA  DC    X'000000'           STORE CURRENT RBA
SAVERBA  DC    X'000000'           STORE RBA FOR LATER READ
MYUSRBA  DC    X'000000'           STORE RBA OF MY USERID FOR LATER
NMSGRBA  DC    X'000000'           RBA OF NEXT MESSAGE
PREVRBA  DC    X'000000'           RBA OF PREVIOUS MESSAGE
MESSRBA  DC    X'000000'           RBA OF CURRENT MESSAGE
FREERBA  DC    X'000000'           RBA OF FREE MESSAGE SLOT FOUND
FRE2RBA  DC    X'000000'           RBA OF FREE MESSAGE SLOT FOUND
NEXTRBA  DC    X'000000'           RBA OF NEXT MESSAGE
MINRBA   DC    X'000000'
NFRERBA  DC    X'000000'           NEW FREE SEARCH RBA FOR TYPE 5
FSRCRBA  DC    X'000000'           FREE SEARCH RECORD RBA - STORED
STORRBA  DC    X'000000'
STOREND  DC    X'000000'
PREVEND  DC    X'000000'
RNAM     DC    X'000000'           FREE SEARCH RECORD RBA - STORED
MYUSSLOT DC    X'00'               STORE SLOT OF MY USERID IN RECORD
NWUSRBA  DC    X'000000'           STORE RBA OF NEW USERID FOR LATER
NWUSSLOT DC    X'00'               STORE SLOT OF NEW USERID IN RECORD
FNUSRBA  DC    X'000000'           RBA OF USERID TO BE FOUND
FNUSSLOT DC    X'00'               SLOT OF THIS USERID IN RECORD
USERID   DS    0CL8                STORE FOUND USERID HERE
USERIDI  DS    CL7                 STORE FOUND USERID HERE
USERIDF  DS    CL1                 8TH CHARACTER
FINDID   DS    0CL8                USERID NAME TO BE FOUND
FINDIDI  DS    CL7                 FIRST 7 CHARACTERS
FINDIDF  DS    CL1                 8TH CHARACTER
TRYID    DS    0CL8                STORE TEST USERID HERE
TRYIDI   DS    CL7                 STORE TEST USERID HERE
TRYIDF   DS    CL1                 8TH CHARACTER
SAVEID   DS    CL8                 STORE USERID HERE
SCANFLAG DC    X'00'               FLAG FOR USERID SCANS
COMPFLAG DC    X'00'               FLAG FOR USERID SCANS
         DS    0F                  ALIGN ON FULLWORD
SAVECPPL DS    F                   SAVE THE CPPL
SAVEUPT  DS    F                   SAVE FOR IKJIFRIF
SAVEPSCB DS    F                   SAVE FOR IKJIFRIF
SAVEECT  DS    F                   SAVE FOR IKJIFRIF
SAVER3A  DS    F                   SAVE REGISTER
SAVER5   DS    F                   SAVE REGISTER
SAVER6   DS    F                   SAVE COUNT FOR USERID SCAN
SAVER7   DS    F                   SAVE REGISTER
SAVER7A  DS    F                   SAVE REGISTER
SAVER8   DS    F                   SAVE REGISTER
SAVER9A  DS    F                   BAL Register Save Area
SAVER9B  DS    F                   BAL Register Save Area
SAVER9C  DS    F                   BAL Register Save Area
SAVER9D  DS    F                   BAL Register Save Area
SAVER9E  DS    F                   BAL Register Save Area
SAVER9F  DS    F                   BAL Register Save Area
SAVER9G  DS    F                   BAL Register Save Area
SAVER9H  DS    F                   BAL Register Save Area
SAVER9I  DS    F                   BAL Register Save Area
SAVER9J  DS    F                   BAL Register Save Area
SAVER9K  DS    F                   BAL Register Save Area
SAVER9L  DS    F                   BAL Register Save Area
SAVER9M  DS    F                   BAL Register Save Area
SAVER9N  DS    F                   BAL Register Save Area
SAVER9O  DS    F                   BAL Register Save Area
SAVER9P  DS    F                   BAL Register Save Area
SAVER9Q  DS    F                   BAL Register Save Area
SAVER9R  DS    F                   BAL Register Save Area
SAVER9S  DS    F                   BAL Register Save Area
SAVER9T  DS    F                   BAL Register Save Area
SAVER9U  DS    F                   BAL Register Save Area
SAVER9V  DS    F                   BAL Register Save Area
SAVER9W  DS    F                   BAL Register Save Area
SAVER9X  DS    F                   BAL Register Save Area
SAVER9Y  DS    F                   BAL Register Save Area
SAVER9Z  DS    F                   BAL Register Save Area
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
MYPPL    DS    7F
MYANS    DS    F
MYECB    DS    F                   USED BY PUTLINE ROUTINE
MYIOPL   DS    4F                  USED BY PUTLINE ROUTINE
MYPTPB   DS    3F                  USED BY PUTLINE ROUTINE
MYPUTLEP DS    F                   USED BY PUTLINE ROUTINE
MYOLD    DS    2F                  USED BY PUTLINE ROUTINE
MYSEG1   DS    2H,CL130            USED BY PUTLINE ROUTINE
PUTSAVE  DS    4F                  USED BY PUTLINE ROUTINE
SAVEINF1 DS    CL8                 PLACE TO STORE CCHHR
LINEB    DS    C                   LINE-1
LINE     DS    CL137
LINET    EQU   LINE+7
         DS    0F
RDWR     READ  MDLDECB,DI,MF=L
RDWREND  DS    0F
RDWRLEN  EQU   *-RDWR
STOR0001 DS    2F
STOR1415 DS    2F
WK1TOTAL DC    C'                                                '
WK1ALL DC C'                                                          '
WK1NOUSR DC    C'                                              '
ALLFLAG  DS    X
FULLFLAG DS    X
FREEFLAG DS    X
CHAINFLG DS    X
OFFSETT  DS    H
CMBLENG  DS    H
MSGTEXT  DS    CL125
SAVEWRK7 DS    F
SAVEWRK8 DS    F
LENTHMSG DS    F
NUMRECS  DS    F
HIWATER  DS    F
         DS    F                   FILLER
         SPACE 1
DATALEN  EQU   *-DATAAREA          LENGTH OF DATA AREA
         IKJCPPL
         IKJUPT
         IKJPSCB
         IKJECT
         IKJIOPL
         IEZIOB   DSECT=YES
         IKJZT301 DSECT=YES
         IKJZT304 DSECT=YES
         IKJZT305 DSECT=YES
         IKJZT306 DSECT=YES
         CVT  DSECT=YES
         END
